// Copyright 2024 Michael Davis
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package pkg

import (
	"bytes"
	"context"
	crand "crypto/rand"
	"encoding/binary"
	"encoding/gob"
	"errors"
	"fmt"
	"log/slog"
	"math/rand/v2"
	"os"
	"strconv"
	"strings"

	"github.com/Michad/tilegroxy/pkg/static"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

var packageName = static.GetPackage()
var version, ref, buildDate = static.GetVersionInformation()
var tracer trace.Tracer = otel.Tracer(packageName)

// The main result type for tiles. Can include a result of any content type - primarily either raster or vector imagery type.
type Image struct {
	// A byte array containing the response data. Always an encoded file format - it shouldn't be raw RGB pixel values.
	Content []byte
	// The Content-Type to force the HTTP response type when returning this image. If an empty string we default to letting Go auto-detect content-type. Should be a valid mime if set
	ContentType string
	// If true it prevents recording this result in the cache
	ForceSkipCache bool
}

// Encodes both content and content type from Image into a single byte array for use in caches
func (i Image) Encode() ([]byte, error) {
	b := bytes.Buffer{}
	e := gob.NewEncoder(&b)

	err := e.Encode("v1")

	if err != nil {
		return nil, err
	}

	err = e.Encode(i.Content)

	if err != nil {
		return nil, err
	}

	err = e.Encode(i.ContentType)

	if err != nil {
		return nil, err
	}

	return b.Bytes(), nil
}

// Generates an image struct from a combined byte array as generated by image.EncodeImage. For use in caches
func DecodeImage(b []byte) (*Image, error) {
	// We encode the binary data with a version and then (for v1) Content followed by Content Type
	// The version number indicates the version of this binary encoding, it's separate from the tilegroxy version number
	// That way if we decide we want to encode additional information we can use the version number to provide backwards compatibility

	i := Image{Content: []byte{}}
	e := gob.NewDecoder(bytes.NewBuffer(b))
	var version string

	err := e.Decode(&version)

	if err != nil || version != "v1" && len(version) > 0 && version[0] != 'v' {
		// For backwards compatibility with data that's just the raw imagery without this encoding scheme
		return &Image{Content: b}, nil
	}

	if version != "v1" {
		// Most likely data was written in a future version of tilegroxy that uses e.g. a v2 schema. We can't see the future
		return nil, errors.New("invalid binary cache version number " + version + "! check deployed tilegroxy version")
	}

	err = e.Decode(&i.Content)

	if err != nil {
		return nil, err
	}

	err = e.Decode(&i.ContentType)

	if err != nil {
		return nil, err
	}

	return &i, nil
}

// Turns a string indicating a range of zoom levels into an explicit array of the zoom levels. Format `<zoom>|<zoom>-<zoom>[,<range>]` e.g. `4` or `1-5` or `1-3,6`
func ParseZoomString(str string) ([]int, error) {
	const errorMessage = "could not parse zoom %v"

	commaSplit := strings.Split(str, ",")

	var result []int

	for _, entry := range commaSplit {
		dashSplit := strings.Split(entry, "-")

		switch len(dashSplit) {
		case 1:
			singleZoom, err := strconv.Atoi(dashSplit[0])

			if singleZoom < 0 || singleZoom > MaxZoom {
				return nil, errors.New("zoom out of range")
			}

			if err == nil {
				result = append(result, singleZoom)
			} else {
				return nil, fmt.Errorf(errorMessage, entry)
			}
		case 2:
			start, err := strconv.Atoi(dashSplit[0])
			end, err2 := strconv.Atoi(dashSplit[1])
			if err != nil || err2 != nil {
				return nil, errors.Join(err, err2)
			}

			if end < start {
				return nil, errors.New("zoom range must start before it ends")
			}

			if start < 0 || end > MaxZoom {
				return nil, errors.New("zoom out of range")
			}

			for i := start; i <= end; i++ {
				result = append(result, i)
			}
		default:
			return nil, fmt.Errorf(errorMessage, entry)
		}
	}

	return result, nil
}

// Find any string values that start with `keyTag.keyName` and replace it with replacer(keyName). Replaces the full value. Used for avoiding secrets in config so your configuration can be placed in source control
func ReplaceConfigValues(rawConfig map[string]interface{}, keyTag string, replacer func(string) (string, error)) (map[string]interface{}, error) {
	var err error
	result := make(map[string]interface{})
	for k, v := range rawConfig {
		if vMap, ok := v.(map[string]interface{}); ok {
			result[k], err = ReplaceConfigValues(vMap, keyTag, replacer)
		} else if vStr, ok := v.(string); ok {
			if strings.Index(vStr, keyTag+".") == 0 {
				varName := vStr[len(keyTag)+1:]
				slog.Debug("Replacing " + keyTag + " var " + varName)

				result[k], err = replacer(varName)
				if err != nil {
					break
				}
			} else {
				result[k] = vStr
			}
		} else {
			result[k] = v
		}
	}

	return result, err
}

// Find any string values that start with `env.` and interpret the rest as an environment variable. Replaces the full value with the contents of the respective environment variable. Useful for avoiding secrets in config so your configuration can be placed in source control
func ReplaceEnv(rawConfig map[string]interface{}) map[string]interface{} {
	result, _ := ReplaceConfigValues(rawConfig, "env", func(s string) (string, error) { return os.Getenv(s), nil })

	return result
}

// cond ? a : b
func Ternary[T any](cond bool, a T, b T) T {
	if cond {
		return a
	}
	return b
}

// Generates a random string with alphanumeric characters. Specifics are prone to change. Not guaranteed to have cryptographic security
func RandomString() string {
	const base = 36
	const length = 16

	var i, i2 uint64
	b := make([]byte, length)

	// Try to use sRNG by default because why not
	_, err := crand.Read(b)

	if err != nil {
		// Fallback on v2 rand since better that than a potentially unrecoverable error
		i = rand.Uint64()
		i2 = rand.Uint64()
	} else {
		i = binary.BigEndian.Uint64(b[0:(length / 2)])
		i2 = binary.BigEndian.Uint64(b[(length / 2):length])
	}

	return strconv.FormatUint(i, base) + strconv.FormatUint(i2, base)
}

// Handles making a new context and span for use in a provider that calls another provider. Make sure to End the span that is returned
func MakeChildSpan(ctx context.Context, newRequest *TileRequest, providerName string, childSpanName string, functionName string) (context.Context, trace.Span) {
	spanName := providerName

	if childSpanName != "" {
		spanName += "-" + childSpanName
	}

	newCtx, span := tracer.Start(ctx, spanName, trace.WithSpanKind(trace.SpanKindInternal))

	if span.IsRecording() {
		span.SetAttributes(
			attribute.String("service.name", "tilegroxy"),
			attribute.String("service.version", version+"-"+ref),
			attribute.String("service.build", buildDate),
			attribute.String("code.function", functionName),
		)

		if newRequest != nil {
			span.SetAttributes(
				attribute.String("tilegroxy.layer.name", newRequest.LayerName),
				attribute.Int("tilegroxy.coordinate.x", newRequest.X),
				attribute.Int("tilegroxy.coordinate.y", newRequest.Y),
				attribute.Int("tilegroxy.coordinate.z", newRequest.Z),
			)
		}
	}

	return newCtx, span
}
